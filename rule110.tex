\documentclass[preprint]{revtex4-1}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{standalone}
\pgfplotsset{compat=newest, table/search path=figures}
\graphicspath{{./figures/}}

\begin{document}
    \title{Self-replicating UTXOs as universal Turing Machine}

    \author{Anonymous authors}

    \date{\today}

    \begin{abstract}
        %        Обычно языки смарт-контрактов рассматривают как выполнимые внутри одной транзакции.
        %        Мы показываем, что при учете цепочек транзакций в совокупности, Тьюринг-полнота возникате при минимальных требованиях к скриптовому языку.
    \end{abstract}

    \maketitle

    \section{Introduction}

    %    Обзор дискуссий по Тьюринг-полноте смарт контрактов. Показываем, что тема актуальная и т.д.
    %    История о Тьюринг полноте вообще - несколько неформальных определений, и то как доказывается тьюринг полнота. Простейший пример - правило 110.
    %    Структура статьи

    \section{Building blocks}


    %    Из чего будем строить машину.
    %    Описание нужного куска языка Эрго

    \section{Rule 110}

    %    Код кидаем в аппендикс, тут описываем его логику.
    %    Картинки как с блоками меняется состояние автомата 110

    \section{How is it possible?}

    %    Описываем, что мы сделали рекурсию через вызов выходом самого себя, хотя в самом языке нет циклов и рекурсии.
    %    Внутриннюю логику можно усложнять для сокращения количества тактов, что приводит к space-time tradeoff, который мы уже описывали в `systematic approach to cryptocurrency fees` - либо пишешь гигантский скрипт, либо скрипт простой, но нужно много тактов.
    %    Правило 110 только это только доказательство полноты, в реальности все делается гораздо эффективнее т.к. в почти любом языке смарт контрактов есть арифметика, не нужно пытаться реализовывать логику через клеточные автоматы.

    \section{Discussion}

    %    Показать что это не экзотика, а достежимо в других языках, например язык Waves и Ethereum (+ посмотреть, что еще есть).
    %  Где же происходят вычисления? ибо мы не задаем алгоритм, а задаем правила верификации. Т.к. в заголовке мы обозначили другой результат, тут обозначить тему и вынести в аппендикс 2

    \section{Appendix 1}

    %    Код правила 110 на Эрго языке ( и ссылка на гитхаб)

    \section{Appendix 2}

    %    Где же происходят вычисления? ибо мы не задаем алгоритм, а задаем правила верификации. Можно сравнение, что в обычном компьютере движущая сила это электричество.. Оффчейн вычисления - требуем найти корни многочлена, или дискретный логарифм.. Посмотреть на декларативные языки программирования, может какие-нидь клеточные автоматы в экселе. Pay-for-proof contracts из биткоина.

    \bibliography{sources}
\end{document}
