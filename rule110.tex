\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\graphicspath{{./figures/}}
\bibliographystyle{splncs04}

\usepackage{nameref}
\usepackage{hyperref}
%\usepackage{amsmath}
\newcommand{\knote}[1]{\textcolor{green}{A: {#1}}}
\newcommand{\dnote}[1]{\textcolor{red}{D: {#1}}}
\newcommand{\vk}[1]{\textcolor{blue}{V: {#1}}}
\newcommand{\payload}{\textit{payload}}
\newcommand{\script}{\textit{script}}
\newcommand{\And}{\&\&}
%\newcommand{\And}{\wedge}
\def\Let#1#2{\State #1 $\gets$ #2}

\begin{document}
    \title{Self--replicating UTXOs as universal Turing Machine}

    \author{Anonymous authors}
    \institute{Anonymous organizations
    \email{anon@anon.an}}

    \date{\today}
    \maketitle

    \begin{abstract}
        %        Обычно Тьюринг-полнота языков смаркт контрактов блокчейне
        % систем связывается с многообразмем возможностей языка, в
        % частности с наличием циклов.
        %        Мы показываем, что даже если в языке явным образом отсутствуют
        % циклы, возможно добиться Тьюринг полноты, если разворачивать
        % рекурсивные вызовы не внутри одной транзакции, а между ними
        %        ??? у системы есть возможность задать зависимость между
        % выходным и входным состояниями транзакции.
        Turing completeness of the smart contract languages in the blockchain
        systems is often associated with the variety of the language features
        (such as loops) within a context of a single transaction.
        A more fundamental problem is combining unpredictability of arbitrary
        script execution time with the blockchain requirements.
        We show that Turing completeness in blockchain environment can
        be achieved through unwinding the recursive calls between
        multiple transactions and blocks instead of using a single one. We prove
        it constructing the simple universal Turing machine using
        the small set of features of the scripting language in the unspent
        transaction output (UTXO) model, which admits the relations between
        input and output transaction states.
        Neither \vk{unbound} loops nor infinite validation time is needed in this approach.
        %\dnote{Don't like `minimalistic`
        %here, UTXO may be not so cryitical and may be even incorrect if we'll
    %add waves example} 
    \keywords{smart contracts, Turing completeness, blockchain, cellular
    automata}
    \end{abstract}

    \section{Introduction}
    %    История о блокчейне - Сатоши и т.д. Биткоин скрипт
    %    Биткоин скрипт начали развивать, утверждая что ему не хватает оператора ГОТО для Тьюринг полноты, обзор дискуссий по Тьюринг-полноте смарт контрактов (возможно тут тезис Черча-Тьюринга). Пачка статей, которые говорят про полноту, но никто не доказывал. 
    %    История о Тьюринг полноте вообще - несколько неформальных определений, тезис Черча-Тьюринга, и то как доказывается тьюринг полнота. Простейший пример - правило 110.
    %    Наш вклад - доказательство тьюринг полноты в UTXO блокчейне без оператора ГОТО через реализацию правила 110.
    %    Структура статьи
    Blockchain technology has become widely adopted after the introduction of
    Bitcoin by S.~Nakamoto~\cite{nakamoto2008bitcoin}. This peer--to--peer
    electronic cash ledger drew the enormous attention from the public, which
    resulted in rapid development of the technology, and appearance of hundreds
    of alternative cryptocurrency projects. It also turned out that the
    blockchain applications expand quite far beyond the simple ledger niche. The
    rules of transaction validation can incorporate complicated logic, which is
    the essence of so--called smart contracts. In the case of Bitcoin this logic
    is implemented in the special purpose Script language, which is believed not
    to be Turing complete. This belief stimulated development of another smart
    contract platforms with the emphasis on the language
    universality. Particularly, in Ethereum~\cite{buterin2014next} the $jump$ opcode was introduced
    in the transaction scripting language in order to incorporate
    unlimited loops. However Turing--completeness of this system is still a
    subject of debates mostly due to the halt problem undecidability.
    For example, in~\cite{miller2016ethereum} it was pointed
    that Turing--complete languages are fundamentally inappropriate for writing
    smart contracts as soon as their execution is halted after some bounded time.
    \dnote{Listen to Andrew video to ensure, he was serious here}
%    Their approach, while being successful in general, exposed few
%    significant complications both from formal and security
%    sides~\cite{atzei2017survey,momot2016seven}.

    Turing complete programming language is the language which admits description
    of the universal Turing machine. The universal Turing machine is the Turing
    machine which can simulate any other Turing machine; its existence is one of
    the main results of the Turing theory~\cite{turing1937computable}. The study
    of Turing machines is strongly motivated by the Church--Turing thesis, which
    states that Turing machines are capable of universal computation. This
    thesis is often viewed at as a definition of computation and
    computability~\cite{turing1939systems}. The set of known
    computation devices and models was rapidly growing during the twentieth
    century, and the methods of their analysis were improved as well. The
    usual way of proving the Turing completeness of a system of rules, device or
    the language is using it to emulate the system that is already proven to be
    Turing complete.
    The system extensively used in our work is one--dimensional
    cellular automaton called Rule 110. It was conjectured to be Turing complete
    by S.~Wolfram~\cite{wolfram1986theory}. The conjecture was proven by
    M.~Cook~\cite{cook2004universality} based on the previous works by
    E.~L.~Post~\cite{post1943formal}.

    The utter internal simplicity of Rule 110 makes it an appealing system for
    the proofs of Turing completeness. In the present work we prove Turing
    completeness of the whole class of the smart contract languages by explicit
    construction of the Rule 110. We do not require neither loops, nor jump
    operator, nor recursive calls inside the transaction. Instead, we treat the
    computation as if it is occurring between the transactions (or, maybe
    blocks). In this context transaction chaining and replication furnishes us
    with potentially infinite loops and recursion, and the union of internal
    transaction registers yields analog of potentially infinite tape. The
    underlying idea of complexity growth is similar to one expressed
    in~\cite{von1951general}.

    The paper is structured as follows: in Section \ref{section2} we first describe the naive
    implementation of Rule 110 using simple Bitcoin--like scripting language.
    Then we discuss the pitfalls arising from compliance with the blockchain
    properties, and show the way to overcome them without language modification.
    Section \ref{section3} contains the discussion of the implementation, language
    requirements, and usability of the method for the real--world blockchain
    applications. \nameref{appendix1} contains the Rule 110 implementations with smart
    contract languages of existing blockchain platforms. \nameref{appendix2} sketches
    the discussion on the nature of computation in the framework of blockchain
    scripting and validation rules.

    \section{Rule 110 implementation}
    \label{section2}
    %    Из чего будем строить машину, Описание нужного куска языка Эрго (возможно это тоже в аппендикс)
    %    Код кидаем в аппендикс, тут описываем его логику. Описываем логику преобразования одной строки.
    %    Картинки как с блоками меняется состояние автомата 110
    %    В блокчейне необходимо иметь константное время валидации для выполнения свойства chain growth (GKL). Для Тьюринг полноты нужно уметь работать со строками произвольного размера, чтобы их валидацуия выполнялась за конечное время, из нужно разбивать на подстроки, крайний случай - 1 бит на выход. (ссылка на код либо в аппендикс, либо на гитхаб)
    Cellular automaton we construct is known as Rule 110.
    It is a one--dimensional string of 0s and 1s together with evolution rules.
    The one step evolution of the bit is defined by its value together with the
    values of the two neighboring bits with the rules shown in the Table
    \ref{tab:transitions}.
    \begin{table}
        \caption{Transition rules for the Rule 110 automaton}
        \label{tab:transitions}
        \centering
        \begin{tabular} {| *{9}{c|} }
            \hline
            Current state & 000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\ \hline
            Next middle bit & 0 & 1 & 1 & 1 & 0 & 1 & 1 & 0 \\
            \hline
        \end{tabular}
    \end{table}

    For the description of Rule 110 implementation in a blockchain, we use Bitcoin--like
    transactions consisting of inputs and outputs. Every output consists of a protecting \script{}
    and a \payload{} while input is a reference to an output from a previous transaction.
    We will assume that the current state of the automaton is stored in the transaction output's \payload{}.
    The general idea is to use the next transaction as a single
    step of the system evolution. In order to achieve this, two main conditions must
    be satisfied. First, the \payload{} of at least one newly generated output should contain
    the updated state of the automaton. Second, this output must contain
    exactly the same script. These conditions require the transaction input to
    have access to the output's \script{}s and \payload{}s. It is implicitly
    present in the vast amount of existing blockchains, since in most cases
    scripts verify the signature of the spending transaction, which is
    constructed over the byte array containing the new outputs. However,
    this way of access to an output's data may be hardly exploitable. In this
    section we assume, that spending script has a direct access to the
    outputs.

    Keeping all these in mind, we come to the following validation
    script structure:
    \begin{equation}
        \label{eq:script}
        isRule110(self.\payload{},\, output[0].\payload{}) \wedge \\
        (self.\script{} == output[0].\script{})
    \end{equation}
    %shown in the Algorithm~\ref{alg:prot}.
    %\begin{algorithm}[H]
    %    \caption{Output protecting \script{}}
    %    \label{alg:prot}
    %    \begin{algorithmic}[1]
    %        %\State isRule110Transformation(self.\payload{}, output(0).\payload{}) \And{}
    %        %\State self.\script{} == output(0).\script{}
    %        \State $isRule110(self.\payload{}, output[0].\payload{}) \And{}
    %        (self.\script{} ==  output[0].\script{})$
    %        \vskip8pt
    %    \end{algorithmic}
    %\end{algorithm}
    The function $isRule110$ returns $true$ if and only if the second argument
    is the one step Rule 110 transformation of the first argument.
    Pseudocode algorithm of this check is shown at Alg. \ref{alg:isRule110}, in
    \nameref{appendix1} we provide the full script implementing the rule 110 in
    the language of the Ergo blockchain.

    \begin{algorithm}[H]
        \caption{isRule110 function that checks, that transformation from inLayer to outLayer is correct}
        \label{alg:isRule110}
        \begin{algorithmic}[1]
            \Function{\sf isRule110}{$inLayer$, $outLayer$}

            \Function{\sf calcBit}{$i$}
            \Let{l}{if(i == 0) inLayer(inLayer.size) else inLayer(i)}
            \Let{c}{inLayer(i)}
            \Let{r}{if(i == inLayer.size) inLayer(0) else inLayer(i)}

            \If{l == 0 \And{} c == 0 \And{} r == 0} \Return 0
            \ElsIf{l == 0 \And{} c == 0 \And{} r == 1} \Return 1
            \ElsIf{l == 0 \And{} c == 1 \And{} r == 0} \Return 1
            \ElsIf{l == 0 \And{} c == 1 \And{} r == 1} \Return 1
            \ElsIf{l == 1 \And{} c == 0 \And{} r == 0} \Return 0
            \ElsIf{l == 1 \And{} c == 0 \And{} r == 1} \Return 0
            \ElsIf{l == 1 \And{} c == 1 \And{} r == 0} \Return 1
            \ElsIf{l == 1 \And{} c == 1 \And{} r == 1} \Return 0
            \EndIf
            \EndFunction

            \State \Return outLayer == inLayer.indices.map(calcBit)
            \EndFunction
            \vskip8pt
        \end{algorithmic}
    \end{algorithm}

    % описание скрипта может быть понадобится в апендиксе
    %    The Ergo scripting language we use treats outputs as the ``boxes'' with the
    %    registers. The validation script has access to the new output registers, and
    %    resides in a separate register itself. It supports byte arrays, logical
    %    operations AND and OR, integer arithmetics, comparison, and sigma protocols
    %    for zero knowledge proofs with native support of AND and OR as basic
    %    elements. The presence of registers both for constants and the script makes
    %    it easy to verify the persistence of the script. Logical operations and
    %    collections, in turn, allow verification correctness of the automaton
    %    transition (whose state is being stored in the separate register). The
    %    schematics of the transactions is presented on Fig.~\ref{fig:txs}.

    With this script constructed, cellular automaton evolution may be started by
    chaining transactions in a blockchain. Fig.~\ref{fig:txs} shows three
    transactions (at the left), each one representing the iteration of Rule 110
    automaton (at the right).

    \begin{figure}[h]
        \centering
        \includegraphics[width=\textwidth]{cell_tx.pdf}
        \caption{Transaction chain following Rule 110. See Eq.~\ref{eq:script} for the
            $script$ field description.
        %\vk{This is placeholder now}
        %\dnote{replace R1 with \payload{} and R2 with \script{}, put correct script.
        %Create links from transaction payload to concrete line in final picture.
        %Reduce number of cells in one line. Transactions from top to bottom}
        \label{fig:txs} }
    \end{figure}

    Potentially infinite number of sequential transactions in the
    blockchain leads to the potentially infinite evolution of cellular
    automaton which is necessary for Turing--complete systems.
    However, there is one pitfall left.
    The size of the data stored in the output must be limited from above, since
    the general blockchain rules~\cite{garay2015bitcoin} require the transaction validation
    time to be bound from above in order to satisfy the
    chain growth property. The workaround is to split
    the automaton state between transactions once it becomes too large. As an
    extreme case one can make a transaction output play a role of a single bit
    of the automaton. While being inefficient this implementation keeps
    the logic simple and complies with the requirements of the blockchain and
    of potentially infinite evolution in space and time. Particular script
    implementation of this logic is provided in \nameref{appendix1}.

    \dnote{would like to see image here similar to \ref{fig:txs}}

    Since the Turing--completeness of the Rule 110 was proven
    in~\cite{cook2004universality}, we conclude that even though the scripting
    language itself does not allow infinite loops, Turing--completeness of the
    system can be achieved by combining multiple transactions together. Note
    that our language requirements are not very demanding, and can be met in a
    number of platforms avoiding complicated ad--hoc structures.

    \section{Discussion}
    \label{section3}
    %    Описываем, что мы сделали рекурсию через вызов выходом самого себя, хотя в самом языке нет циклов и рекурсии.
    %    Внутриннюю логику можно усложнять для сокращения количества тактов, что приводит к space-time tradeoff - либо пишешь гигантский скрипт который выполняется за 1 такт, либо скрипт простой, но нужно много тактов.
    %    Правило 110 только это только доказательство полноты, в реальности все делается гораздо эффективнее т.к. в почти любом языке смарт контрактов есть арифметика, не нужно пытаться реализовывать логику через клеточные автоматы.
    %    Показать что это не экзотика, а достежимо в других языках, например язык Waves и Ethereum (+ посмотреть, что еще есть).
    %    Практические выводы: 1) позволяет ответить на вопрос, какой класс задач возможно реализовать в данном языке смарт контрактов. 2) Открывает возможность писать тяжелые смарт контраты, требуемые вычисления которых превышают лимит вычислений на блок, 3) ???
    %    Где же происходят вычисления? ибо мы не задаем алгоритм, а задаем правила верификации. Т.к. в заголовке мы обозначили другой результат, тут обозначить тему и вынести в аппендикс 2
    The most important move in our work was unwinding recursive calls by means
    of transaction chaining, although the language contained neither cycles nor
    recursion. By doing this we let the program be executed over the set of
    transactions and blocks. This, in turn helped us to pass around the halting
    problem, which used to make arbitrary script execution impossible inside a
    transaction in the view of chain growth property. Roughly speaking, single
    transaction in our approach corresponds to a single cycle of the computation
    machine. The trade--off is again between the consumed space and execution time:
    one can either incorporate complex logic in the script, and expect
    relatively fast execution, or leave the script logic short and simple, but
    the execution can consume more transactions.

    It worth noting that any practical algorithm implementation can be
    significantly optimized using the language built--ins such as arithmetic
    operations. Our construction is not needed for that. It merely just
    guarantees that any algorithm can be potentially implemented and executed.
    \vk{We also claim that the described situation is common, and not only
    restricted to the Ergo language. Using aforementioned point of view one
    can prove the Turing completeness of another blockchain scripting
    languages, such as \ldots}

    Another practical conclusion is the fact that one can construct and execute
    algorithms exceeding the hard computation limit per block by chaining them
    between different blocks.

    As a drawback, one can argue that the set of validation rules is not exactly
    the programming language, since it doesn't prescript the sequence of actions,
    but rather the way to check whether the result is correct. Here we stay on the
    practical side: in our case the validation description is detailed enough to
    convert it to the strict sequence of actions, hence it actually defines an
    algorithm. For the more detailed discussion on the subject we address reader
    to Appendix~2.

    \bibliography{sources}

    \section{Appendix~1}
    \label{appendix1}
    %    Код правила 110 на Эрго языке ( и ссылка на гитхаб)

    \section{Appendix~2}
    \label{appendix2}

    %    Где же происходят вычисления? ибо мы не задаем алгоритм, а задаем правила верификации. Можно сравнение, что в обычном компьютере движущая сила это электричество.. Оффчейн вычисления - требуем найти корни многочлена, или дискретный логарифм.. Посмотреть на декларативные языки программирования, может какие-нидь клеточные автоматы в экселе. Pay-for-proof contracts из биткоина.

\end{document}
