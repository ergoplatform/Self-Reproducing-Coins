\documentclass[preprint]{revtex4-1}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{standalone}
\pgfplotsset{compat=newest, table/search path=figures}
\graphicspath{{./figures/}}

\begin{document}
    \title{Self-replicating UTXOs as universal Turing Machine}

    \author{Anonymous authors}

    \date{\today}

    \begin{abstract}
        %        Обычно Тьюринг-полнота языков смаркт контрактов блокчейне систем связывается с многообразмем возможностей языка, в частности с наличием циклов.
        %        Мы показываем, что даже если в языке явным образом отсутствуют циклы, возможно добиться Тьюринг полноты, если разворачивать рекурсивные вызовы не внутри одной транзакции, а между ними
        % ??? у системы есть возможность задать зависимость между выходным и входным состояниями транзакции.
    \end{abstract}

    \maketitle

    \section{Introduction}

    %    История о блокчейне - Сатоши и т.д. Биткоин скрипт
    %    Биткоин скрипт начали развивать, утверждая что ему не хватает оператора ГОТО для Тьюринг полноты, обзор дискуссий по Тьюринг-полноте смарт контрактов (возможно тут тезис Черча-Тьюринга). Пачка статей, которые говорят про полноту, но никто не доказывал. 
    %    История о Тьюринг полноте вообще - несколько неформальных определений, тезис Черча-Тьюринга, и то как доказывается тьюринг полнота. Простейший пример - правило 110.
    %    Наш вклад - доказательство тьюринг полноты в UTXO блокчейне без оператора ГОТО через реализацию правила 110.
    %    Структура статьи

    \section{Rule 110 implementation}

    %    Из чего будем строить машину, Описание нужного куска языка Эрго (возможно это тоже в аппендикс)
    %    Код кидаем в аппендикс, тут описываем его логику. Описываем логику преобразования одной строки.
    %    Картинки как с блоками меняется состояние автомата 110
    %    В блокчейне необходимо иметь константное время валидации для выполнения свойства chain growth (GKL). Для Тьюринг полноты нужно уметь работать со строками произвольного размера, чтобы их валидацуия выполнялась за конечное время, из нужно разбивать на подстроки, крайний случай - 1 бит на выход. (ссылка на код либо в аппендикс, либо на гитхаб)


    \section{Discussion}

    %    Описываем, что мы сделали рекурсию через вызов выходом самого себя, хотя в самом языке нет циклов и рекурсии.
    %    Внутриннюю логику можно усложнять для сокращения количества тактов, что приводит к space-time tradeoff - либо пишешь гигантский скрипт который выполняется за 1 такт, либо скрипт простой, но нужно много тактов.
    %    Правило 110 только это только доказательство полноты, в реальности все делается гораздо эффективнее т.к. в почти любом языке смарт контрактов есть арифметика, не нужно пытаться реализовывать логику через клеточные автоматы.
    %    Показать что это не экзотика, а достежимо в других языках, например язык Waves и Ethereum (+ посмотреть, что еще есть).
    %    Практические выводы: 1) позволяет ответить на вопрос, какой класс задач возможно реализовать в данном языке смарт контрактов. 2) Открывает возможность писать тяжелые смарт контраты, требуемые вычисления которых превышают лимит вычислений на блок, 3) ???
    %    Где же происходят вычисления? ибо мы не задаем алгоритм, а задаем правила верификации. Т.к. в заголовке мы обозначили другой результат, тут обозначить тему и вынести в аппендикс 2

    \section{Appendix 1}

    %    Код правила 110 на Эрго языке ( и ссылка на гитхаб)

    \section{Appendix 2}

    %    Где же происходят вычисления? ибо мы не задаем алгоритм, а задаем правила верификации. Можно сравнение, что в обычном компьютере движущая сила это электричество.. Оффчейн вычисления - требуем найти корни многочлена, или дискретный логарифм.. Посмотреть на декларативные языки программирования, может какие-нидь клеточные автоматы в экселе. Pay-for-proof contracts из биткоина.

    \bibliography{sources}
\end{document}
